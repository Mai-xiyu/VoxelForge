"""
Litematic 导出器 — Litematica .litematic 格式

使用 litemapy 库实现，Litematica 是最流行的投影 mod 之一。

结构简述:
    .litematic (NBT gzipped)
    ├── Metadata
    │   ├── Name, Author, Description, TimeCreated, TimeModified
    │   ├── TotalVolume, TotalBlocks
    │   └── EnclosingSize: {x, y, z}
    ├── Regions
    │   └── "RegionName"
    │       ├── Position: {x, y, z}
    │       ├── Size: {x, y, z}
    │       ├── BlockStatePalette: [...]
    │       └── BlockStates: long array
    └── MinecraftDataVersion
"""

from __future__ import annotations

import logging
import time
from pathlib import Path
from typing import Callable, Optional

from core.sparse_voxels import SparseVoxelGrid

logger = logging.getLogger(__name__)


class LitematicExporter:
    """
    Litematica .litematic 导出器

    Usage::

        exporter = LitematicExporter()
        exporter.export(grid, "my_build.litematic")
    """

    def __init__(self) -> None:
        self._litemapy = None
        try:
            import litemapy
            self._litemapy = litemapy
            logger.info("litemapy loaded")
        except ImportError:
            logger.warning("litemapy not installed — .litematic export unavailable")

    @property
    def available(self) -> bool:
        return self._litemapy is not None

    def export(
        self,
        grid: SparseVoxelGrid,
        output_path: str | Path,
        name: str = "VoxelForge Build",
        author: str = "VoxelForge",
        description: str = "",
        progress_callback: Optional[Callable[[float, str], None]] = None,
    ) -> None:
        """
        将 SparseVoxelGrid 导出为 .litematic 文件。
        """
        if not self.available:
            raise RuntimeError("litemapy is not installed. Install with: pip install litemapy")

        output_path = Path(output_path)

        def report(pct: float, msg: str) -> None:
            if progress_callback:
                progress_callback(pct, msg)

        report(0.0, "准备导出 Litematic…")

        if grid.count == 0:
            raise ValueError("Empty grid, nothing to export")

        bmin, bmax = grid.bounds

        width = bmax[0] - bmin[0] + 1
        height = bmax[1] - bmin[1] + 1
        length = bmax[2] - bmin[2] + 1

        logger.info("Litematic region: %d × %d × %d", width, height, length)
        report(10.0, f"区域大小: {width}×{height}×{length}")

        lm = self._litemapy

        # 创建 Schematic
        schematic = lm.Schematic(
            name=name,
            author=author,
            description=description or f"Generated by VoxelForge at {time.strftime('%Y-%m-%d %H:%M')}",
        )

        # 创建 Region
        region = lm.Region(0, 0, 0, width, height, length)

        report(20.0, "填充方块…")

        # 方块状态缓存
        block_cache = {}
        block_cache["minecraft:air"] = lm.BlockState("minecraft:air")

        total = grid.count
        done = 0

        for (x, y, z), block_id in grid._data.items():
            # 转为区域内坐标
            lx = x - bmin[0]
            ly = y - bmin[1]
            lz = z - bmin[2]

            # 解析 block_id
            if isinstance(block_id, int):
                bid = f"minecraft:block_{block_id}"
            else:
                bid = str(block_id)

            # 解析 block state 属性
            # 支持 "minecraft:oak_stairs[facing=north,half=bottom]" 格式
            props = {}
            base_id = bid
            if "[" in bid and bid.endswith("]"):
                base_id = bid[:bid.index("[")]
                props_str = bid[bid.index("[") + 1:-1]
                for pair in props_str.split(","):
                    if "=" in pair:
                        k, v = pair.split("=", 1)
                        props[k.strip()] = v.strip()

            if bid not in block_cache:
                block_cache[bid] = lm.BlockState(base_id, **props)

            region.setblock(lx, ly, lz, block_cache[bid])

            done += 1
            if done % 10000 == 0:
                pct = 20.0 + (done / total) * 60.0
                report(pct, f"放置方块 {done}/{total}…")

        report(85.0, "写入文件…")

        schematic.regions["Main"] = region
        schematic.save(str(output_path))

        logger.info("Exported Litematic: %s (%d blocks)", output_path.name, grid.count)
        report(100.0, f"导出完成: {output_path.name}")


class LitematicImporter:
    """
    从 .litematic 文件导入为 SparseVoxelGrid。
    """

    def __init__(self) -> None:
        self._litemapy = None
        try:
            import litemapy
            self._litemapy = litemapy
        except ImportError:
            pass

    @property
    def available(self) -> bool:
        return self._litemapy is not None

    def load(
        self,
        path: str | Path,
        progress_callback: Optional[Callable[[float, str], None]] = None,
    ) -> SparseVoxelGrid:
        """加载 .litematic → SparseVoxelGrid"""
        if not self.available:
            raise RuntimeError("litemapy not installed")

        path = Path(path)
        lm = self._litemapy

        def report(pct: float, msg: str) -> None:
            if progress_callback:
                progress_callback(pct, msg)

        report(0.0, "加载 Litematic…")

        schematic = lm.Schematic.load(str(path))
        grid = SparseVoxelGrid()

        total_blocks = 0
        for name, region in schematic.regions.items():
            report(20.0, f"读取区域: {name}")
            rx, ry, rz = region.xrange(), region.yrange(), region.zrange()

            for x in rx:
                for y in ry:
                    for z in rz:
                        block = region.getblock(x, y, z)
                        if block is not None and block.blockid != "minecraft:air":
                            # 重建完整 block state 字符串
                            bid = block.blockid
                            if block.properties:
                                props_str = ",".join(f"{k}={v}" for k, v in block.properties.items())
                                bid = f"{bid}[{props_str}]"
                            grid.set(
                                region.x + x,
                                region.y + y,
                                region.z + z,
                                bid,
                            )
                            total_blocks += 1

        logger.info("Imported Litematic: %s (%d blocks from %d regions)",
                     path.name, total_blocks, len(schematic.regions))
        report(100.0, f"导入完成: {total_blocks} 方块")

        return grid
